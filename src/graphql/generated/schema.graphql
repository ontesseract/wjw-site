schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false
  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

input AuthAnonymousInput {
  deviceId: String!
}

input AuthEmailInput {
  email: citext!
  state: String
  useVerificationCode: Boolean
}

input AuthEmailPasswordInput {
  email: citext!
  password: String!
}

input AuthEmailPasswordSignUpInput {
  displayNameOverride: String
  email: citext!
  firstName: String
  lastName: String
  password: String!
  state: String
  useVerificationCode: Boolean
  username: citext
}

input AuthEmailSignupInput {
  displayNameOverride: String
  email: citext!
  firstName: String
  lastName: String
  state: String
  useVerificationCode: Boolean
  username: citext
}

input AuthEmailTicketInput {
  email: citext!
  ticket: String!
}

type AuthOutput {
  profileId: uuid
  refreshToken: String
  sessionId: String
  token: String
}

input AuthResetPasswordInput {
  email: citext!
  password: String!
  ticket: String!
}

"""
columns and relationships of "auth_role_kind"
"""
type AuthRoleKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "auth_role_kind". All fields are combined with a logical 'AND'.
"""
input AuthRoleKindBoolExp {
  _and: [AuthRoleKindBoolExp!]
  _not: AuthRoleKindBoolExp
  _or: [AuthRoleKindBoolExp!]
  id: StringComparisonExp
}

"""Ordering options when selecting data from "auth_role_kind"."""
input AuthRoleKindOrderBy {
  id: OrderBy
}

"""
select columns of table "auth_role_kind"
"""
enum AuthRoleKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "auth_role_kind"
"""
input AuthRoleKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: AuthRoleKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input AuthRoleKindStreamCursorValueInput {
  id: String
}

input AuthSmsCodeInput {
  code: String!
  mobile: citext!
}

input AuthSmsInput {
  mobile: citext!
}

input AuthSmsSignUpInput {
  displayNameOverride: String
  firstName: String
  lastName: String
  mobile: citext!
  username: citext
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input CitextComparisonExp {
  _eq: citext
  _gt: citext
  _gte: citext
  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _isNull: Boolean
  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext
  """does the column NOT match the given pattern"""
  _nlike: citext
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext
  """does the column match the given SQL regular expression"""
  _similar: citext
}

input ContactFormInput {
  data: jsonb!
  email: String!
  name: String!
  profileId: String
  tenantId: String!
  turnstileToken: String!
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC
  """descending ordering of the cursor"""
  DESC
}

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
columns and relationships of "document"
"""
type Document {
  createdAt: timestamptz!
  id: uuid!
  isDeleted: Boolean!
  kind: DocumentKindEnum!
  profileId: uuid
  slug: citext!
  tenantId: String!
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
}

"""
columns and relationships of "document_block"
"""
type DocumentBlock {
  body: String
  """An array relationship"""
  childBlocks(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]
    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!
  createdAt: timestamptz!
  """An object relationship"""
  document: Document!
  documentId: uuid!
  id: uuid!
  kind: DocumentBlockKindEnum!
  """An object relationship"""
  mediaItem: MediaItem
  mediaItemId: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  """An object relationship"""
  parentBlock: DocumentBlock
  parentBlockId: uuid
  tenantId: String!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "document_block"
"""
input DocumentBlockAggregateOrderBy {
  count: OrderBy
  max: DocumentBlockMaxOrderBy
  min: DocumentBlockMinOrderBy
}

"""
Boolean expression to filter rows from the table "document_block". All fields are combined with a logical 'AND'.
"""
input DocumentBlockBoolExp {
  _and: [DocumentBlockBoolExp!]
  _not: DocumentBlockBoolExp
  _or: [DocumentBlockBoolExp!]
  body: StringComparisonExp
  childBlocks: DocumentBlockBoolExp
  createdAt: TimestamptzComparisonExp
  document: DocumentBoolExp
  documentId: UuidComparisonExp
  id: UuidComparisonExp
  kind: DocumentBlockKindEnumComparisonExp
  mediaItem: MediaItemBoolExp
  mediaItemId: StringComparisonExp
  metadata: JsonbComparisonExp
  parentBlock: DocumentBlockBoolExp
  parentBlockId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
columns and relationships of "document_block_kind"
"""
type DocumentBlockKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "document_block_kind". All fields are combined with a logical 'AND'.
"""
input DocumentBlockKindBoolExp {
  _and: [DocumentBlockKindBoolExp!]
  _not: DocumentBlockKindBoolExp
  _or: [DocumentBlockKindBoolExp!]
  id: StringComparisonExp
}

enum DocumentBlockKindEnum {
  IMAGE
  TEXT
}

"""
Boolean expression to compare columns of type "DocumentBlockKindEnum". All fields are combined with logical 'AND'.
"""
input DocumentBlockKindEnumComparisonExp {
  _eq: DocumentBlockKindEnum
  _in: [DocumentBlockKindEnum!]
  _isNull: Boolean
  _neq: DocumentBlockKindEnum
  _nin: [DocumentBlockKindEnum!]
}

"""Ordering options when selecting data from "document_block_kind"."""
input DocumentBlockKindOrderBy {
  id: OrderBy
}

"""
select columns of table "document_block_kind"
"""
enum DocumentBlockKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "document_block_kind"
"""
input DocumentBlockKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentBlockKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentBlockKindStreamCursorValueInput {
  id: String
}

"""
order by max() on columns of table "document_block"
"""
input DocumentBlockMaxOrderBy {
  body: OrderBy
  createdAt: OrderBy
  documentId: OrderBy
  id: OrderBy
  mediaItemId: OrderBy
  parentBlockId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
order by min() on columns of table "document_block"
"""
input DocumentBlockMinOrderBy {
  body: OrderBy
  createdAt: OrderBy
  documentId: OrderBy
  id: OrderBy
  mediaItemId: OrderBy
  parentBlockId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""Ordering options when selecting data from "document_block"."""
input DocumentBlockOrderBy {
  body: OrderBy
  childBlocksAggregate: DocumentBlockAggregateOrderBy
  createdAt: OrderBy
  document: DocumentOrderBy
  documentId: OrderBy
  id: OrderBy
  kind: OrderBy
  mediaItem: MediaItemOrderBy
  mediaItemId: OrderBy
  metadata: OrderBy
  parentBlock: DocumentBlockOrderBy
  parentBlockId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "document_block"
"""
enum DocumentBlockSelectColumn {
  """column name"""
  body
  """column name"""
  createdAt
  """column name"""
  documentId
  """column name"""
  id
  """column name"""
  kind
  """column name"""
  mediaItemId
  """column name"""
  metadata
  """column name"""
  parentBlockId
  """column name"""
  tenantId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "document_block"
"""
input DocumentBlockStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentBlockStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentBlockStreamCursorValueInput {
  body: String
  createdAt: timestamptz
  documentId: uuid
  id: uuid
  kind: DocumentBlockKindEnum
  mediaItemId: String
  metadata: jsonb
  parentBlockId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
Boolean expression to filter rows from the table "document". All fields are combined with a logical 'AND'.
"""
input DocumentBoolExp {
  _and: [DocumentBoolExp!]
  _not: DocumentBoolExp
  _or: [DocumentBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  isDeleted: BooleanComparisonExp
  kind: DocumentKindEnumComparisonExp
  profileId: UuidComparisonExp
  slug: CitextComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
columns and relationships of "document_kind"
"""
type DocumentKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "document_kind". All fields are combined with a logical 'AND'.
"""
input DocumentKindBoolExp {
  _and: [DocumentKindBoolExp!]
  _not: DocumentKindBoolExp
  _or: [DocumentKindBoolExp!]
  id: StringComparisonExp
}

enum DocumentKindEnum {
  AGREEMENT
  PAGE
}

"""
Boolean expression to compare columns of type "DocumentKindEnum". All fields are combined with logical 'AND'.
"""
input DocumentKindEnumComparisonExp {
  _eq: DocumentKindEnum
  _in: [DocumentKindEnum!]
  _isNull: Boolean
  _neq: DocumentKindEnum
  _nin: [DocumentKindEnum!]
}

"""Ordering options when selecting data from "document_kind"."""
input DocumentKindOrderBy {
  id: OrderBy
}

"""
select columns of table "document_kind"
"""
enum DocumentKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "document_kind"
"""
input DocumentKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentKindStreamCursorValueInput {
  id: String
}

"""Ordering options when selecting data from "document"."""
input DocumentOrderBy {
  createdAt: OrderBy
  id: OrderBy
  isDeleted: OrderBy
  kind: OrderBy
  profileId: OrderBy
  slug: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""
select columns of table "document"
"""
enum DocumentSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  isDeleted
  """column name"""
  kind
  """column name"""
  profileId
  """column name"""
  slug
  """column name"""
  tenantId
  """column name"""
  updatedAt
  """column name"""
  visibility
}

"""
Streaming cursor of the table "document"
"""
input DocumentStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DocumentStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DocumentStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: DocumentKindEnum
  profileId: uuid
  slug: citext
  tenantId: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "event"
"""
type Event {
  """An object relationship"""
  coverPhoto: MediaItem
  coverPhotoId: String
  createdAt: timestamptz!
  endDate: date!
  endTimestamp: timestamptz
  """An object relationship"""
  eventLive: EventLive
  id: uuid!
  isDeleted: Boolean!
  kind: String!
  label: String
  link: String
  """An object relationship"""
  location: GeoLocation
  locationId: uuid
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  name: citext!
  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  raffleId: uuid
  """An object relationship"""
  recurrence: EventRecurrence
  recurrenceId: uuid
  slug: String
  startDate: date!
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String!
  """An array relationship"""
  ticketOptions(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]
    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!
  timezone: String!
  updatedAt: timestamptz!
  visibility: VisibilityKindEnum!
}

"""
columns and relationships of "event_availability_kind"
"""
type EventAvailabilityKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "event_availability_kind". All fields are combined with a logical 'AND'.
"""
input EventAvailabilityKindBoolExp {
  _and: [EventAvailabilityKindBoolExp!]
  _not: EventAvailabilityKindBoolExp
  _or: [EventAvailabilityKindBoolExp!]
  id: StringComparisonExp
}

"""Ordering options when selecting data from "event_availability_kind"."""
input EventAvailabilityKindOrderBy {
  id: OrderBy
}

"""
select columns of table "event_availability_kind"
"""
enum EventAvailabilityKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "event_availability_kind"
"""
input EventAvailabilityKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventAvailabilityKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventAvailabilityKindStreamCursorValueInput {
  id: String
}

"""
Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
"""
input EventBoolExp {
  _and: [EventBoolExp!]
  _not: EventBoolExp
  _or: [EventBoolExp!]
  coverPhoto: MediaItemBoolExp
  coverPhotoId: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  endTimestamp: TimestamptzComparisonExp
  eventLive: EventLiveBoolExp
  id: UuidComparisonExp
  isDeleted: BooleanComparisonExp
  kind: StringComparisonExp
  label: StringComparisonExp
  link: StringComparisonExp
  location: GeoLocationBoolExp
  locationId: UuidComparisonExp
  metadata: JsonbComparisonExp
  name: CitextComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  raffleId: UuidComparisonExp
  recurrence: EventRecurrenceBoolExp
  recurrenceId: UuidComparisonExp
  slug: StringComparisonExp
  startDate: DateComparisonExp
  startTimestamp: TimestamptzComparisonExp
  templateId: UuidComparisonExp
  tenantId: StringComparisonExp
  ticketOptions: EventTicketOptionBoolExp
  timezone: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""
columns and relationships of "event_live"
"""
type EventLive {
  cleanupReady: Boolean
  createdAt: timestamptz
  """An object relationship"""
  event: Event!
  eventId: uuid!
  id: String!
  isLive: Boolean
  isPaused: Boolean
  """Gets the response counts for the currently active question_set"""
  liveResponseCounts(
    """JSON select path"""
    path: String
  ): jsonb
  nextTimer: timestamptz
  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  questionId: uuid
  questionSetId: uuid
  """An object relationship"""
  raffle: GameRaffle
  raffleId: uuid
  """
  A computed field, executes function "current_time"
  """
  serverTime: timestamptz
  showAfterQuestionDetails: Boolean!
  startTimestamp: timestamptz
  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  updatedAt: timestamptz
}

"""
Boolean expression to filter rows from the table "event_live". All fields are combined with a logical 'AND'.
"""
input EventLiveBoolExp {
  _and: [EventLiveBoolExp!]
  _not: EventLiveBoolExp
  _or: [EventLiveBoolExp!]
  cleanupReady: BooleanComparisonExp
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: UuidComparisonExp
  id: StringComparisonExp
  isLive: BooleanComparisonExp
  isPaused: BooleanComparisonExp
  liveResponseCounts: JsonbComparisonExp
  nextTimer: TimestamptzComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  questionId: UuidComparisonExp
  questionSetId: UuidComparisonExp
  raffle: GameRaffleBoolExp
  raffleId: UuidComparisonExp
  serverTime: TimestamptzComparisonExp
  showAfterQuestionDetails: BooleanComparisonExp
  startTimestamp: TimestamptzComparisonExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""Ordering options when selecting data from "event_live"."""
input EventLiveOrderBy {
  cleanupReady: OrderBy
  createdAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  id: OrderBy
  isLive: OrderBy
  isPaused: OrderBy
  liveResponseCounts: OrderBy
  nextTimer: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  questionId: OrderBy
  questionSetId: OrderBy
  raffle: GameRaffleOrderBy
  raffleId: OrderBy
  serverTime: OrderBy
  showAfterQuestionDetails: OrderBy
  startTimestamp: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "event_live"
"""
enum EventLiveSelectColumn {
  """column name"""
  cleanupReady
  """column name"""
  createdAt
  """column name"""
  eventId
  """column name"""
  id
  """column name"""
  isLive
  """column name"""
  isPaused
  """column name"""
  nextTimer
  """column name"""
  profileId
  """column name"""
  questionId
  """column name"""
  questionSetId
  """column name"""
  raffleId
  """column name"""
  showAfterQuestionDetails
  """column name"""
  startTimestamp
  """column name"""
  tenantId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "event_live"
"""
input EventLiveStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventLiveStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventLiveStreamCursorValueInput {
  cleanupReady: Boolean
  createdAt: timestamptz
  eventId: uuid
  id: String
  isLive: Boolean
  isPaused: Boolean
  nextTimer: timestamptz
  profileId: uuid
  questionId: uuid
  questionSetId: uuid
  raffleId: uuid
  showAfterQuestionDetails: Boolean
  startTimestamp: timestamptz
  tenantId: String
  updatedAt: timestamptz
}

"""Ordering options when selecting data from "event"."""
input EventOrderBy {
  coverPhoto: MediaItemOrderBy
  coverPhotoId: OrderBy
  createdAt: OrderBy
  endDate: OrderBy
  endTimestamp: OrderBy
  eventLive: EventLiveOrderBy
  id: OrderBy
  isDeleted: OrderBy
  kind: OrderBy
  label: OrderBy
  link: OrderBy
  location: GeoLocationOrderBy
  locationId: OrderBy
  metadata: OrderBy
  name: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  raffleId: OrderBy
  recurrence: EventRecurrenceOrderBy
  recurrenceId: OrderBy
  slug: OrderBy
  startDate: OrderBy
  startTimestamp: OrderBy
  templateId: OrderBy
  tenantId: OrderBy
  ticketOptionsAggregate: EventTicketOptionAggregateOrderBy
  timezone: OrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""
columns and relationships of "event_recurrence"
"""
type EventRecurrence {
  createdAt: timestamptz!
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz
  """An object relationship"""
  event: Event
  id: uuid!
  kind: EventRecurrenceKindEnum!
  month: Int
  tenantId: String!
  updatedAt: timestamptz!
}

"""
Boolean expression to filter rows from the table "event_recurrence". All fields are combined with a logical 'AND'.
"""
input EventRecurrenceBoolExp {
  _and: [EventRecurrenceBoolExp!]
  _not: EventRecurrenceBoolExp
  _or: [EventRecurrenceBoolExp!]
  createdAt: TimestamptzComparisonExp
  dayOfMonth: IntComparisonExp
  daysOfWeek: StringArrayComparisonExp
  endsAt: TimestamptzComparisonExp
  event: EventBoolExp
  id: UuidComparisonExp
  kind: EventRecurrenceKindEnumComparisonExp
  month: IntComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

enum EventRecurrenceKindEnum {
  DAILY
  MONTHLY
  WEEKLY
  YEARLY
}

"""
Boolean expression to compare columns of type "EventRecurrenceKindEnum". All fields are combined with logical 'AND'.
"""
input EventRecurrenceKindEnumComparisonExp {
  _eq: EventRecurrenceKindEnum
  _in: [EventRecurrenceKindEnum!]
  _isNull: Boolean
  _neq: EventRecurrenceKindEnum
  _nin: [EventRecurrenceKindEnum!]
}

"""Ordering options when selecting data from "event_recurrence"."""
input EventRecurrenceOrderBy {
  createdAt: OrderBy
  dayOfMonth: OrderBy
  daysOfWeek: OrderBy
  endsAt: OrderBy
  event: EventOrderBy
  id: OrderBy
  kind: OrderBy
  month: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "event_recurrence"
"""
enum EventRecurrenceSelectColumn {
  """column name"""
  createdAt
  """column name"""
  dayOfMonth
  """column name"""
  daysOfWeek
  """column name"""
  endsAt
  """column name"""
  id
  """column name"""
  kind
  """column name"""
  month
  """column name"""
  tenantId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "event_recurrence"
"""
input EventRecurrenceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventRecurrenceStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventRecurrenceStreamCursorValueInput {
  createdAt: timestamptz
  dayOfMonth: Int
  daysOfWeek: [String!]
  endsAt: timestamptz
  id: uuid
  kind: EventRecurrenceKindEnum
  month: Int
  tenantId: String
  updatedAt: timestamptz
}

"""
select columns of table "event"
"""
enum EventSelectColumn {
  """column name"""
  coverPhotoId
  """column name"""
  createdAt
  """column name"""
  endDate
  """column name"""
  endTimestamp
  """column name"""
  id
  """column name"""
  isDeleted
  """column name"""
  kind
  """column name"""
  label
  """column name"""
  link
  """column name"""
  locationId
  """column name"""
  metadata
  """column name"""
  name
  """column name"""
  profileId
  """column name"""
  raffleId
  """column name"""
  recurrenceId
  """column name"""
  slug
  """column name"""
  startDate
  """column name"""
  startTimestamp
  """column name"""
  templateId
  """column name"""
  tenantId
  """column name"""
  timezone
  """column name"""
  updatedAt
  """column name"""
  visibility
}

"""
Streaming cursor of the table "event"
"""
input EventStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventStreamCursorValueInput {
  coverPhotoId: String
  createdAt: timestamptz
  endDate: date
  endTimestamp: timestamptz
  id: uuid
  isDeleted: Boolean
  kind: String
  label: String
  link: String
  locationId: uuid
  metadata: jsonb
  name: citext
  profileId: uuid
  raffleId: uuid
  recurrenceId: uuid
  slug: String
  startDate: date
  startTimestamp: timestamptz
  templateId: uuid
  tenantId: String
  timezone: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "event_ticket_option"
"""
type EventTicketOption {
  createdAt: timestamptz!
  """An object relationship"""
  event: Event!
  eventId: uuid!
  """An object relationship"""
  product: ShopProduct!
  productId: uuid!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "event_ticket_option"
"""
input EventTicketOptionAggregateOrderBy {
  count: OrderBy
  max: EventTicketOptionMaxOrderBy
  min: EventTicketOptionMinOrderBy
}

"""
Boolean expression to filter rows from the table "event_ticket_option". All fields are combined with a logical 'AND'.
"""
input EventTicketOptionBoolExp {
  _and: [EventTicketOptionBoolExp!]
  _not: EventTicketOptionBoolExp
  _or: [EventTicketOptionBoolExp!]
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  eventId: UuidComparisonExp
  product: ShopProductBoolExp
  productId: UuidComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
order by max() on columns of table "event_ticket_option"
"""
input EventTicketOptionMaxOrderBy {
  createdAt: OrderBy
  eventId: OrderBy
  productId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
order by min() on columns of table "event_ticket_option"
"""
input EventTicketOptionMinOrderBy {
  createdAt: OrderBy
  eventId: OrderBy
  productId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""Ordering options when selecting data from "event_ticket_option"."""
input EventTicketOptionOrderBy {
  createdAt: OrderBy
  event: EventOrderBy
  eventId: OrderBy
  product: ShopProductOrderBy
  productId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "event_ticket_option"
"""
enum EventTicketOptionSelectColumn {
  """column name"""
  createdAt
  """column name"""
  eventId
  """column name"""
  productId
  """column name"""
  tenantId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "event_ticket_option"
"""
input EventTicketOptionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: EventTicketOptionStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input EventTicketOptionStreamCursorValueInput {
  createdAt: timestamptz
  eventId: uuid
  productId: uuid
  tenantId: String
  updatedAt: timestamptz
}

input FeedbackInput {
  email: String!
  feedback: String!
  name: String!
  navigationStateJSON: String
  profileId: String
  sourceScreen: String
  tenantId: String!
}

type FeedbackOutput {
  success: Boolean!
}

"""
columns and relationships of "game_raffle"
"""
type GameRaffle {
  createdAt: timestamptz
  description: String
  id: uuid!
  name: String!
  """An object relationship"""
  profile: Profile!
  profileId: uuid!
  prompt: String
  promptDescription: String
  """An array relationship"""
  rafflePrizes(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]
    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!
  """An aggregate relationship"""
  rafflePrizesAggregate(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]
    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): GameRafflePrizeAggregate!
  """An array relationship"""
  raffleTicketOptions(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]
    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!
  """An aggregate relationship"""
  raffleTicketOptionsAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]
    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): GameRaffleTicketOptionAggregate!
  updatedAt: timestamptz
  visibility: VisibilityKindEnum!
}

"""
Boolean expression to filter rows from the table "game_raffle". All fields are combined with a logical 'AND'.
"""
input GameRaffleBoolExp {
  _and: [GameRaffleBoolExp!]
  _not: GameRaffleBoolExp
  _or: [GameRaffleBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  profile: ProfileBoolExp
  profileId: UuidComparisonExp
  prompt: StringComparisonExp
  promptDescription: StringComparisonExp
  rafflePrizes: GameRafflePrizeBoolExp
  rafflePrizesAggregate: GameRafflePrizeAggregateBoolExp
  raffleTicketOptions: GameRaffleTicketOptionBoolExp
  raffleTicketOptionsAggregate: GameRaffleTicketOptionAggregateBoolExp
  updatedAt: TimestamptzComparisonExp
  visibility: VisibilityKindEnumComparisonExp
}

"""Ordering options when selecting data from "game_raffle"."""
input GameRaffleOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  profile: ProfileOrderBy
  profileId: OrderBy
  prompt: OrderBy
  promptDescription: OrderBy
  rafflePrizesAggregate: GameRafflePrizeAggregateOrderBy
  raffleTicketOptionsAggregate: GameRaffleTicketOptionAggregateOrderBy
  updatedAt: OrderBy
  visibility: OrderBy
}

"""
columns and relationships of "game_raffle_prize"
"""
type GameRafflePrize {
  createdAt: timestamptz
  description: String
  id: uuid!
  name: String!
  """An object relationship"""
  raffle: GameRaffle!
  raffleId: uuid!
  updatedAt: timestamptz
}

"""
aggregated selection of "game_raffle_prize"
"""
type GameRafflePrizeAggregate {
  aggregate: GameRafflePrizeAggregateFields
  nodes: [GameRafflePrize!]!
}

input GameRafflePrizeAggregateBoolExp {
  count: gameRafflePrizeAggregateBoolExpCount
}

"""
aggregate fields of "game_raffle_prize"
"""
type GameRafflePrizeAggregateFields {
  count(columns: [GameRafflePrizeSelectColumn!], distinct: Boolean): Int!
  max: GameRafflePrizeMaxFields
  min: GameRafflePrizeMinFields
}

"""
order by aggregate values of table "game_raffle_prize"
"""
input GameRafflePrizeAggregateOrderBy {
  count: OrderBy
  max: GameRafflePrizeMaxOrderBy
  min: GameRafflePrizeMinOrderBy
}

"""
Boolean expression to filter rows from the table "game_raffle_prize". All fields are combined with a logical 'AND'.
"""
input GameRafflePrizeBoolExp {
  _and: [GameRafflePrizeBoolExp!]
  _not: GameRafflePrizeBoolExp
  _or: [GameRafflePrizeBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: UuidComparisonExp
  name: StringComparisonExp
  raffle: GameRaffleBoolExp
  raffleId: UuidComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""aggregate max on columns"""
type GameRafflePrizeMaxFields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffleId: uuid
  updatedAt: timestamptz
}

"""
order by max() on columns of table "game_raffle_prize"
"""
input GameRafflePrizeMaxOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  raffleId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type GameRafflePrizeMinFields {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffleId: uuid
  updatedAt: timestamptz
}

"""
order by min() on columns of table "game_raffle_prize"
"""
input GameRafflePrizeMinOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  raffleId: OrderBy
  updatedAt: OrderBy
}

"""Ordering options when selecting data from "game_raffle_prize"."""
input GameRafflePrizeOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  name: OrderBy
  raffle: GameRaffleOrderBy
  raffleId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "game_raffle_prize"
"""
enum GameRafflePrizeSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  raffleId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "game_raffle_prize"
"""
input GameRafflePrizeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GameRafflePrizeStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GameRafflePrizeStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  raffleId: uuid
  updatedAt: timestamptz
}

"""
select columns of table "game_raffle"
"""
enum GameRaffleSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  id
  """column name"""
  name
  """column name"""
  profileId
  """column name"""
  prompt
  """column name"""
  promptDescription
  """column name"""
  updatedAt
  """column name"""
  visibility
}

"""
Streaming cursor of the table "game_raffle"
"""
input GameRaffleStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GameRaffleStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GameRaffleStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  id: uuid
  name: String
  profileId: uuid
  prompt: String
  promptDescription: String
  updatedAt: timestamptz
  visibility: VisibilityKindEnum
}

"""
columns and relationships of "game_raffle_ticket_option"
"""
type GameRaffleTicketOption {
  createdAt: timestamptz
  id: uuid!
  instructions: String
  isRequired: Boolean
  kind: GameRaffleTicketOptionKindEnum!
  """An object relationship"""
  raffle: GameRaffle!
  raffleId: uuid!
  ticketsGranted: Int!
  updatedAt: timestamptz
}

"""
aggregated selection of "game_raffle_ticket_option"
"""
type GameRaffleTicketOptionAggregate {
  aggregate: GameRaffleTicketOptionAggregateFields
  nodes: [GameRaffleTicketOption!]!
}

input GameRaffleTicketOptionAggregateBoolExp {
  bool_and: gameRaffleTicketOptionAggregateBoolExpBool_and
  bool_or: gameRaffleTicketOptionAggregateBoolExpBool_or
  count: gameRaffleTicketOptionAggregateBoolExpCount
}

"""
aggregate fields of "game_raffle_ticket_option"
"""
type GameRaffleTicketOptionAggregateFields {
  avg: GameRaffleTicketOptionAvgFields
  count(columns: [GameRaffleTicketOptionSelectColumn!], distinct: Boolean): Int!
  max: GameRaffleTicketOptionMaxFields
  min: GameRaffleTicketOptionMinFields
  stddev: GameRaffleTicketOptionStddevFields
  stddevPop: GameRaffleTicketOptionStddevPopFields
  stddevSamp: GameRaffleTicketOptionStddevSampFields
  sum: GameRaffleTicketOptionSumFields
  varPop: GameRaffleTicketOptionVarPopFields
  varSamp: GameRaffleTicketOptionVarSampFields
  variance: GameRaffleTicketOptionVarianceFields
}

"""
order by aggregate values of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionAggregateOrderBy {
  avg: GameRaffleTicketOptionAvgOrderBy
  count: OrderBy
  max: GameRaffleTicketOptionMaxOrderBy
  min: GameRaffleTicketOptionMinOrderBy
  stddev: GameRaffleTicketOptionStddevOrderBy
  stddevPop: GameRaffleTicketOptionStddevPopOrderBy
  stddevSamp: GameRaffleTicketOptionStddevSampOrderBy
  sum: GameRaffleTicketOptionSumOrderBy
  varPop: GameRaffleTicketOptionVarPopOrderBy
  varSamp: GameRaffleTicketOptionVarSampOrderBy
  variance: GameRaffleTicketOptionVarianceOrderBy
}

"""aggregate avg on columns"""
type GameRaffleTicketOptionAvgFields {
  ticketsGranted: Float
}

"""
order by avg() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionAvgOrderBy {
  ticketsGranted: OrderBy
}

"""
Boolean expression to filter rows from the table "game_raffle_ticket_option". All fields are combined with a logical 'AND'.
"""
input GameRaffleTicketOptionBoolExp {
  _and: [GameRaffleTicketOptionBoolExp!]
  _not: GameRaffleTicketOptionBoolExp
  _or: [GameRaffleTicketOptionBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: UuidComparisonExp
  instructions: StringComparisonExp
  isRequired: BooleanComparisonExp
  kind: GameRaffleTicketOptionKindEnumComparisonExp
  raffle: GameRaffleBoolExp
  raffleId: UuidComparisonExp
  ticketsGranted: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}

enum GameRaffleTicketOptionKindEnum {
  MAILING_LIST
  SMS_NOTIFICATIONS
}

"""
Boolean expression to compare columns of type "GameRaffleTicketOptionKindEnum". All fields are combined with logical 'AND'.
"""
input GameRaffleTicketOptionKindEnumComparisonExp {
  _eq: GameRaffleTicketOptionKindEnum
  _in: [GameRaffleTicketOptionKindEnum!]
  _isNull: Boolean
  _neq: GameRaffleTicketOptionKindEnum
  _nin: [GameRaffleTicketOptionKindEnum!]
}

"""aggregate max on columns"""
type GameRaffleTicketOptionMaxFields {
  createdAt: timestamptz
  id: uuid
  instructions: String
  raffleId: uuid
  ticketsGranted: Int
  updatedAt: timestamptz
}

"""
order by max() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  instructions: OrderBy
  raffleId: OrderBy
  ticketsGranted: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type GameRaffleTicketOptionMinFields {
  createdAt: timestamptz
  id: uuid
  instructions: String
  raffleId: uuid
  ticketsGranted: Int
  updatedAt: timestamptz
}

"""
order by min() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  instructions: OrderBy
  raffleId: OrderBy
  ticketsGranted: OrderBy
  updatedAt: OrderBy
}

"""Ordering options when selecting data from "game_raffle_ticket_option"."""
input GameRaffleTicketOptionOrderBy {
  createdAt: OrderBy
  id: OrderBy
  instructions: OrderBy
  isRequired: OrderBy
  kind: OrderBy
  raffle: GameRaffleOrderBy
  raffleId: OrderBy
  ticketsGranted: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  instructions
  """column name"""
  isRequired
  """column name"""
  kind
  """column name"""
  raffleId
  """column name"""
  ticketsGranted
  """column name"""
  updatedAt
}

"""
select "gameRaffleTicketOptionAggregateBoolExpBool_andArgumentsColumns" columns of table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_andArgumentsColumns {
  """column name"""
  isRequired
}

"""
select "gameRaffleTicketOptionAggregateBoolExpBool_orArgumentsColumns" columns of table "game_raffle_ticket_option"
"""
enum GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_orArgumentsColumns {
  """column name"""
  isRequired
}

"""aggregate stddev on columns"""
type GameRaffleTicketOptionStddevFields {
  ticketsGranted: Float
}

"""
order by stddev() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStddevOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate stddevPop on columns"""
type GameRaffleTicketOptionStddevPopFields {
  ticketsGranted: Float
}

"""
order by stddevPop() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStddevPopOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate stddevSamp on columns"""
type GameRaffleTicketOptionStddevSampFields {
  ticketsGranted: Float
}

"""
order by stddevSamp() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStddevSampOrderBy {
  ticketsGranted: OrderBy
}

"""
Streaming cursor of the table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GameRaffleTicketOptionStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GameRaffleTicketOptionStreamCursorValueInput {
  createdAt: timestamptz
  id: uuid
  instructions: String
  isRequired: Boolean
  kind: GameRaffleTicketOptionKindEnum
  raffleId: uuid
  ticketsGranted: Int
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type GameRaffleTicketOptionSumFields {
  ticketsGranted: Int
}

"""
order by sum() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionSumOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate varPop on columns"""
type GameRaffleTicketOptionVarPopFields {
  ticketsGranted: Float
}

"""
order by varPop() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionVarPopOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate varSamp on columns"""
type GameRaffleTicketOptionVarSampFields {
  ticketsGranted: Float
}

"""
order by varSamp() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionVarSampOrderBy {
  ticketsGranted: OrderBy
}

"""aggregate variance on columns"""
type GameRaffleTicketOptionVarianceFields {
  ticketsGranted: Float
}

"""
order by variance() on columns of table "game_raffle_ticket_option"
"""
input GameRaffleTicketOptionVarianceOrderBy {
  ticketsGranted: OrderBy
}

"""
columns and relationships of "geo_location"
"""
type GeoLocation {
  city: String
  country: String!
  countryCode: String!
  createdAt: timestamptz!
  """An object relationship"""
  event: Event
  formatted: String
  id: uuid!
  latitude: numeric!
  longitude: numeric!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  name: String
  postalCode: String
  """An object relationship"""
  profile: Profile
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String!
  timezone: String
  updatedAt: timestamptz!
}

"""
Boolean expression to filter rows from the table "geo_location". All fields are combined with a logical 'AND'.
"""
input GeoLocationBoolExp {
  _and: [GeoLocationBoolExp!]
  _not: GeoLocationBoolExp
  _or: [GeoLocationBoolExp!]
  city: StringComparisonExp
  country: StringComparisonExp
  countryCode: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  event: EventBoolExp
  formatted: StringComparisonExp
  id: UuidComparisonExp
  latitude: NumericComparisonExp
  longitude: NumericComparisonExp
  metadata: JsonbComparisonExp
  name: StringComparisonExp
  postalCode: StringComparisonExp
  profile: ProfileBoolExp
  state: StringComparisonExp
  stateCode: StringComparisonExp
  street1: StringComparisonExp
  street2: StringComparisonExp
  tenantId: StringComparisonExp
  timezone: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""Ordering options when selecting data from "geo_location"."""
input GeoLocationOrderBy {
  city: OrderBy
  country: OrderBy
  countryCode: OrderBy
  createdAt: OrderBy
  event: EventOrderBy
  formatted: OrderBy
  id: OrderBy
  latitude: OrderBy
  longitude: OrderBy
  metadata: OrderBy
  name: OrderBy
  postalCode: OrderBy
  profile: ProfileOrderBy
  state: OrderBy
  stateCode: OrderBy
  street1: OrderBy
  street2: OrderBy
  tenantId: OrderBy
  timezone: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "geo_location"
"""
enum GeoLocationSelectColumn {
  """column name"""
  city
  """column name"""
  country
  """column name"""
  countryCode
  """column name"""
  createdAt
  """column name"""
  formatted
  """column name"""
  id
  """column name"""
  latitude
  """column name"""
  longitude
  """column name"""
  metadata
  """column name"""
  name
  """column name"""
  postalCode
  """column name"""
  state
  """column name"""
  stateCode
  """column name"""
  street1
  """column name"""
  street2
  """column name"""
  tenantId
  """column name"""
  timezone
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "geo_location"
"""
input GeoLocationStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: GeoLocationStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input GeoLocationStreamCursorValueInput {
  city: String
  country: String
  countryCode: String
  createdAt: timestamptz
  formatted: String
  id: uuid
  latitude: numeric
  longitude: numeric
  metadata: jsonb
  name: String
  postalCode: String
  state: String
  stateCode: String
  street1: String
  street2: String
  tenantId: String
  timezone: String
  updatedAt: timestamptz
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp
  """is the column contained in the given json value"""
  _containedIn: jsonb
  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  """does the string exist as a top-level key in the column"""
  _hasKey: String
  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]
  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "media_item"
"""
type MediaItem {
  blurHash: String!
  contentLength: Int!
  contentType: String!
  createdAt: timestamptz!
  defaultUrl: String!
  filename: String!
  height: Int!
  id: String!
  kind: MediaKindEnum!
  """An array relationship"""
  tags(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]
    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!
  tenantId: String!
  thumbnailUrl: String!
  updatedAt: timestamptz!
  width: Int!
}

"""
Boolean expression to filter rows from the table "media_item". All fields are combined with a logical 'AND'.
"""
input MediaItemBoolExp {
  _and: [MediaItemBoolExp!]
  _not: MediaItemBoolExp
  _or: [MediaItemBoolExp!]
  blurHash: StringComparisonExp
  contentLength: IntComparisonExp
  contentType: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  defaultUrl: StringComparisonExp
  filename: StringComparisonExp
  height: IntComparisonExp
  id: StringComparisonExp
  kind: MediaKindEnumComparisonExp
  tags: MediaItemTagBoolExp
  tenantId: StringComparisonExp
  thumbnailUrl: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  width: IntComparisonExp
}

"""Ordering options when selecting data from "media_item"."""
input MediaItemOrderBy {
  blurHash: OrderBy
  contentLength: OrderBy
  contentType: OrderBy
  createdAt: OrderBy
  defaultUrl: OrderBy
  filename: OrderBy
  height: OrderBy
  id: OrderBy
  kind: OrderBy
  tagsAggregate: MediaItemTagAggregateOrderBy
  tenantId: OrderBy
  thumbnailUrl: OrderBy
  updatedAt: OrderBy
  width: OrderBy
}

"""
select columns of table "media_item"
"""
enum MediaItemSelectColumn {
  """column name"""
  blurHash
  """column name"""
  contentLength
  """column name"""
  contentType
  """column name"""
  createdAt
  """column name"""
  defaultUrl
  """column name"""
  filename
  """column name"""
  height
  """column name"""
  id
  """column name"""
  kind
  """column name"""
  tenantId
  """column name"""
  thumbnailUrl
  """column name"""
  updatedAt
  """column name"""
  width
}

"""
Streaming cursor of the table "media_item"
"""
input MediaItemStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MediaItemStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MediaItemStreamCursorValueInput {
  blurHash: String
  contentLength: Int
  contentType: String
  createdAt: timestamptz
  defaultUrl: String
  filename: String
  height: Int
  id: String
  kind: MediaKindEnum
  tenantId: String
  thumbnailUrl: String
  updatedAt: timestamptz
  width: Int
}

"""
columns and relationships of "media_item_tag"
"""
type MediaItemTag {
  createdAt: timestamptz!
  """An object relationship"""
  mediaItem: MediaItem!
  mediaItemId: String!
  tag: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
order by aggregate values of table "media_item_tag"
"""
input MediaItemTagAggregateOrderBy {
  count: OrderBy
  max: MediaItemTagMaxOrderBy
  min: MediaItemTagMinOrderBy
}

"""
Boolean expression to filter rows from the table "media_item_tag". All fields are combined with a logical 'AND'.
"""
input MediaItemTagBoolExp {
  _and: [MediaItemTagBoolExp!]
  _not: MediaItemTagBoolExp
  _or: [MediaItemTagBoolExp!]
  createdAt: TimestamptzComparisonExp
  mediaItem: MediaItemBoolExp
  mediaItemId: StringComparisonExp
  tag: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
order by max() on columns of table "media_item_tag"
"""
input MediaItemTagMaxOrderBy {
  createdAt: OrderBy
  mediaItemId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
order by min() on columns of table "media_item_tag"
"""
input MediaItemTagMinOrderBy {
  createdAt: OrderBy
  mediaItemId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""Ordering options when selecting data from "media_item_tag"."""
input MediaItemTagOrderBy {
  createdAt: OrderBy
  mediaItem: MediaItemOrderBy
  mediaItemId: OrderBy
  tag: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "media_item_tag"
"""
enum MediaItemTagSelectColumn {
  """column name"""
  createdAt
  """column name"""
  mediaItemId
  """column name"""
  tag
  """column name"""
  tenantId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "media_item_tag"
"""
input MediaItemTagStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MediaItemTagStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MediaItemTagStreamCursorValueInput {
  createdAt: timestamptz
  mediaItemId: String
  tag: String
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "media_kind"
"""
type MediaKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "media_kind". All fields are combined with a logical 'AND'.
"""
input MediaKindBoolExp {
  _and: [MediaKindBoolExp!]
  _not: MediaKindBoolExp
  _or: [MediaKindBoolExp!]
  id: StringComparisonExp
}

enum MediaKindEnum {
  CLOUDFLARE_IMAGE
  CLOUDFLARE_VIDEO
  SVG_AVATAR
  WEB_IMAGE
}

"""
Boolean expression to compare columns of type "MediaKindEnum". All fields are combined with logical 'AND'.
"""
input MediaKindEnumComparisonExp {
  _eq: MediaKindEnum
  _in: [MediaKindEnum!]
  _isNull: Boolean
  _neq: MediaKindEnum
  _nin: [MediaKindEnum!]
}

"""Ordering options when selecting data from "media_kind"."""
input MediaKindOrderBy {
  id: OrderBy
}

"""
select columns of table "media_kind"
"""
enum MediaKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "media_kind"
"""
input MediaKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: MediaKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input MediaKindStreamCursorValueInput {
  id: String
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC
  """in ascending order, nulls first"""
  ASC_NULLS_FIRST
  """in ascending order, nulls last"""
  ASC_NULLS_LAST
  """in descending order, nulls first"""
  DESC
  """in descending order, nulls first"""
  DESC_NULLS_FIRST
  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

"""
columns and relationships of "post_reaction_kind"
"""
type PostReactionKind {
  createdAt: timestamptz!
  id: String!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
Boolean expression to filter rows from the table "post_reaction_kind". All fields are combined with a logical 'AND'.
"""
input PostReactionKindBoolExp {
  _and: [PostReactionKindBoolExp!]
  _not: PostReactionKindBoolExp
  _or: [PostReactionKindBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""Ordering options when selecting data from "post_reaction_kind"."""
input PostReactionKindOrderBy {
  createdAt: OrderBy
  id: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "post_reaction_kind"
"""
enum PostReactionKindSelectColumn {
  """column name"""
  createdAt
  """column name"""
  id
  """column name"""
  tenantId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "post_reaction_kind"
"""
input PostReactionKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PostReactionKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PostReactionKindStreamCursorValueInput {
  createdAt: timestamptz
  id: String
  tenantId: String
  updatedAt: timestamptz
}

"""
columns and relationships of "profile"
"""
type Profile {
  """An array relationship"""
  attributes(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]
    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!
  bio: String
  """An array relationship"""
  childProfileNodes(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]
    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!
  createdAt: timestamptz!
  """
  A computed field, executes function "display_name"
  """
  displayName: String
  facebookUsername: String
  """An array relationship"""
  followedProfiles(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!
  """An aggregate relationship"""
  followedProfilesAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!
  """An array relationship"""
  followers(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!
  """An aggregate relationship"""
  followersAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!
  id: uuid!
  instagramUsername: String
  kind: String!
  """An object relationship"""
  location: GeoLocation
  locationId: uuid
  metaData(
    """JSON select path"""
    path: String
  ): jsonb!
  parentNodeId: uuid
  """An object relationship"""
  parentProfileNode: Profile
  """An object relationship"""
  photo: MediaItem
  photoId: String
  startDate: date
  """An object relationship"""
  tenant: Tenant!
  tenantId: String!
  tiktokUsername: String
  updatedAt: timestamptz!
  username: citext!
  xUsername: String
}

"""
order by aggregate values of table "profile"
"""
input ProfileAggregateOrderBy {
  count: OrderBy
  max: ProfileMaxOrderBy
  min: ProfileMinOrderBy
}

"""
columns and relationships of "profile_attribute"
"""
type ProfileAttribute {
  createdAt: timestamptz!
  kind: String!
  order: Int
  updatedAt: timestamptz!
  value: String!
}

"""
order by aggregate values of table "profile_attribute"
"""
input ProfileAttributeAggregateOrderBy {
  avg: ProfileAttributeAvgOrderBy
  count: OrderBy
  max: ProfileAttributeMaxOrderBy
  min: ProfileAttributeMinOrderBy
  stddev: ProfileAttributeStddevOrderBy
  stddevPop: ProfileAttributeStddevPopOrderBy
  stddevSamp: ProfileAttributeStddevSampOrderBy
  sum: ProfileAttributeSumOrderBy
  varPop: ProfileAttributeVarPopOrderBy
  varSamp: ProfileAttributeVarSampOrderBy
  variance: ProfileAttributeVarianceOrderBy
}

"""
order by avg() on columns of table "profile_attribute"
"""
input ProfileAttributeAvgOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "profile_attribute". All fields are combined with a logical 'AND'.
"""
input ProfileAttributeBoolExp {
  _and: [ProfileAttributeBoolExp!]
  _not: ProfileAttributeBoolExp
  _or: [ProfileAttributeBoolExp!]
  createdAt: TimestamptzComparisonExp
  kind: StringComparisonExp
  order: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
  value: StringComparisonExp
}

"""
order by max() on columns of table "profile_attribute"
"""
input ProfileAttributeMaxOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  order: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""
order by min() on columns of table "profile_attribute"
"""
input ProfileAttributeMinOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  order: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""Ordering options when selecting data from "profile_attribute"."""
input ProfileAttributeOrderBy {
  createdAt: OrderBy
  kind: OrderBy
  order: OrderBy
  updatedAt: OrderBy
  value: OrderBy
}

"""
select columns of table "profile_attribute"
"""
enum ProfileAttributeSelectColumn {
  """column name"""
  createdAt
  """column name"""
  kind
  """column name"""
  order
  """column name"""
  updatedAt
  """column name"""
  value
}

"""
order by stddev() on columns of table "profile_attribute"
"""
input ProfileAttributeStddevOrderBy {
  order: OrderBy
}

"""
order by stddevPop() on columns of table "profile_attribute"
"""
input ProfileAttributeStddevPopOrderBy {
  order: OrderBy
}

"""
order by stddevSamp() on columns of table "profile_attribute"
"""
input ProfileAttributeStddevSampOrderBy {
  order: OrderBy
}

"""
Streaming cursor of the table "profile_attribute"
"""
input ProfileAttributeStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileAttributeStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileAttributeStreamCursorValueInput {
  createdAt: timestamptz
  kind: String
  order: Int
  updatedAt: timestamptz
  value: String
}

"""
order by sum() on columns of table "profile_attribute"
"""
input ProfileAttributeSumOrderBy {
  order: OrderBy
}

"""
order by varPop() on columns of table "profile_attribute"
"""
input ProfileAttributeVarPopOrderBy {
  order: OrderBy
}

"""
order by varSamp() on columns of table "profile_attribute"
"""
input ProfileAttributeVarSampOrderBy {
  order: OrderBy
}

"""
order by variance() on columns of table "profile_attribute"
"""
input ProfileAttributeVarianceOrderBy {
  order: OrderBy
}

"""
Boolean expression to filter rows from the table "profile". All fields are combined with a logical 'AND'.
"""
input ProfileBoolExp {
  _and: [ProfileBoolExp!]
  _not: ProfileBoolExp
  _or: [ProfileBoolExp!]
  attributes: ProfileAttributeBoolExp
  bio: StringComparisonExp
  childProfileNodes: ProfileBoolExp
  createdAt: TimestamptzComparisonExp
  displayName: StringComparisonExp
  facebookUsername: StringComparisonExp
  followedProfiles: ProfileFollowerBoolExp
  followedProfilesAggregate: ProfileFollowerAggregateBoolExp
  followers: ProfileFollowerBoolExp
  followersAggregate: ProfileFollowerAggregateBoolExp
  id: UuidComparisonExp
  instagramUsername: StringComparisonExp
  kind: StringComparisonExp
  location: GeoLocationBoolExp
  locationId: UuidComparisonExp
  metaData: JsonbComparisonExp
  parentNodeId: UuidComparisonExp
  parentProfileNode: ProfileBoolExp
  photo: MediaItemBoolExp
  photoId: StringComparisonExp
  startDate: DateComparisonExp
  tenant: TenantBoolExp
  tenantId: StringComparisonExp
  tiktokUsername: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
  username: CitextComparisonExp
  xUsername: StringComparisonExp
}

input ProfileCheckUsernameInput {
  username: citext!
}

type ProfileCheckUsernameOutput {
  isAvailable: Boolean!
  suggestedUsername: String
}

"""
columns and relationships of "profile_follower"
"""
type ProfileFollower {
  createdAt: timestamptz!
  """An object relationship"""
  followedProfile: Profile!
  followedProfileId: uuid!
  """An object relationship"""
  follower: Profile!
  followerId: uuid!
  kind: ProfileFollowerKindEnum!
  tenantId: String!
  updatedAt: timestamptz!
}

"""
aggregated selection of "profile_follower"
"""
type ProfileFollowerAggregate {
  aggregate: ProfileFollowerAggregateFields
  nodes: [ProfileFollower!]!
}

input ProfileFollowerAggregateBoolExp {
  count: profileFollowerAggregateBoolExpCount
}

"""
aggregate fields of "profile_follower"
"""
type ProfileFollowerAggregateFields {
  count(columns: [ProfileFollowerSelectColumn!], distinct: Boolean): Int!
  max: ProfileFollowerMaxFields
  min: ProfileFollowerMinFields
}

"""
order by aggregate values of table "profile_follower"
"""
input ProfileFollowerAggregateOrderBy {
  count: OrderBy
  max: ProfileFollowerMaxOrderBy
  min: ProfileFollowerMinOrderBy
}

"""
Boolean expression to filter rows from the table "profile_follower". All fields are combined with a logical 'AND'.
"""
input ProfileFollowerBoolExp {
  _and: [ProfileFollowerBoolExp!]
  _not: ProfileFollowerBoolExp
  _or: [ProfileFollowerBoolExp!]
  createdAt: TimestamptzComparisonExp
  followedProfile: ProfileBoolExp
  followedProfileId: UuidComparisonExp
  follower: ProfileBoolExp
  followerId: UuidComparisonExp
  kind: ProfileFollowerKindEnumComparisonExp
  tenantId: StringComparisonExp
  updatedAt: TimestamptzComparisonExp
}

enum ProfileFollowerKindEnum {
  ORGANIZATION
  SOCIAL
}

"""
Boolean expression to compare columns of type "ProfileFollowerKindEnum". All fields are combined with logical 'AND'.
"""
input ProfileFollowerKindEnumComparisonExp {
  _eq: ProfileFollowerKindEnum
  _in: [ProfileFollowerKindEnum!]
  _isNull: Boolean
  _neq: ProfileFollowerKindEnum
  _nin: [ProfileFollowerKindEnum!]
}

"""aggregate max on columns"""
type ProfileFollowerMaxFields {
  createdAt: timestamptz
  followedProfileId: uuid
  followerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "profile_follower"
"""
input ProfileFollowerMaxOrderBy {
  createdAt: OrderBy
  followedProfileId: OrderBy
  followerId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""aggregate min on columns"""
type ProfileFollowerMinFields {
  createdAt: timestamptz
  followedProfileId: uuid
  followerId: uuid
  tenantId: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "profile_follower"
"""
input ProfileFollowerMinOrderBy {
  createdAt: OrderBy
  followedProfileId: OrderBy
  followerId: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""Ordering options when selecting data from "profile_follower"."""
input ProfileFollowerOrderBy {
  createdAt: OrderBy
  followedProfile: ProfileOrderBy
  followedProfileId: OrderBy
  follower: ProfileOrderBy
  followerId: OrderBy
  kind: OrderBy
  tenantId: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "profile_follower"
"""
enum ProfileFollowerSelectColumn {
  """column name"""
  createdAt
  """column name"""
  followedProfileId
  """column name"""
  followerId
  """column name"""
  kind
  """column name"""
  tenantId
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "profile_follower"
"""
input ProfileFollowerStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileFollowerStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileFollowerStreamCursorValueInput {
  createdAt: timestamptz
  followedProfileId: uuid
  followerId: uuid
  kind: ProfileFollowerKindEnum
  tenantId: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "profile"
"""
input ProfileMaxOrderBy {
  bio: OrderBy
  createdAt: OrderBy
  facebookUsername: OrderBy
  id: OrderBy
  instagramUsername: OrderBy
  kind: OrderBy
  locationId: OrderBy
  parentNodeId: OrderBy
  photoId: OrderBy
  startDate: OrderBy
  tenantId: OrderBy
  tiktokUsername: OrderBy
  updatedAt: OrderBy
  username: OrderBy
  xUsername: OrderBy
}

"""
order by min() on columns of table "profile"
"""
input ProfileMinOrderBy {
  bio: OrderBy
  createdAt: OrderBy
  facebookUsername: OrderBy
  id: OrderBy
  instagramUsername: OrderBy
  kind: OrderBy
  locationId: OrderBy
  parentNodeId: OrderBy
  photoId: OrderBy
  startDate: OrderBy
  tenantId: OrderBy
  tiktokUsername: OrderBy
  updatedAt: OrderBy
  username: OrderBy
  xUsername: OrderBy
}

"""Ordering options when selecting data from "profile"."""
input ProfileOrderBy {
  attributesAggregate: ProfileAttributeAggregateOrderBy
  bio: OrderBy
  childProfileNodesAggregate: ProfileAggregateOrderBy
  createdAt: OrderBy
  displayName: OrderBy
  facebookUsername: OrderBy
  followedProfilesAggregate: ProfileFollowerAggregateOrderBy
  followersAggregate: ProfileFollowerAggregateOrderBy
  id: OrderBy
  instagramUsername: OrderBy
  kind: OrderBy
  location: GeoLocationOrderBy
  locationId: OrderBy
  metaData: OrderBy
  parentNodeId: OrderBy
  parentProfileNode: ProfileOrderBy
  photo: MediaItemOrderBy
  photoId: OrderBy
  startDate: OrderBy
  tenant: TenantOrderBy
  tenantId: OrderBy
  tiktokUsername: OrderBy
  updatedAt: OrderBy
  username: OrderBy
  xUsername: OrderBy
}

"""
select columns of table "profile"
"""
enum ProfileSelectColumn {
  """column name"""
  bio
  """column name"""
  createdAt
  """column name"""
  facebookUsername
  """column name"""
  id
  """column name"""
  instagramUsername
  """column name"""
  kind
  """column name"""
  locationId
  """column name"""
  metaData
  """column name"""
  parentNodeId
  """column name"""
  photoId
  """column name"""
  startDate
  """column name"""
  tenantId
  """column name"""
  tiktokUsername
  """column name"""
  updatedAt
  """column name"""
  username
  """column name"""
  xUsername
}

"""
Streaming cursor of the table "profile"
"""
input ProfileStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ProfileStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ProfileStreamCursorValueInput {
  bio: String
  createdAt: timestamptz
  facebookUsername: String
  id: uuid
  instagramUsername: String
  kind: String
  locationId: uuid
  metaData: jsonb
  parentNodeId: uuid
  photoId: String
  startDate: date
  tenantId: String
  tiktokUsername: String
  updatedAt: timestamptz
  username: citext
  xUsername: String
}

"""
columns and relationships of "question_kind"
"""
type QuestionKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "question_kind". All fields are combined with a logical 'AND'.
"""
input QuestionKindBoolExp {
  _and: [QuestionKindBoolExp!]
  _not: QuestionKindBoolExp
  _or: [QuestionKindBoolExp!]
  id: StringComparisonExp
}

"""Ordering options when selecting data from "question_kind"."""
input QuestionKindOrderBy {
  id: OrderBy
}

"""
select columns of table "question_kind"
"""
enum QuestionKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "question_kind"
"""
input QuestionKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: QuestionKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input QuestionKindStreamCursorValueInput {
  id: String
}

"""
columns and relationships of "shop_product"
"""
type ShopProduct {
  createdAt: timestamptz!
  description: String
  externalId: String
  id: uuid!
  kind: ShopProductKindEnum!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb!
  name: String!
  price: Int!
  sku: String!
  tenantId: String!
  trialPeriodDays: Int
  updatedAt: timestamptz!
}

"""
Boolean expression to filter rows from the table "shop_product". All fields are combined with a logical 'AND'.
"""
input ShopProductBoolExp {
  _and: [ShopProductBoolExp!]
  _not: ShopProductBoolExp
  _or: [ShopProductBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  externalId: StringComparisonExp
  id: UuidComparisonExp
  kind: ShopProductKindEnumComparisonExp
  metadata: JsonbComparisonExp
  name: StringComparisonExp
  price: IntComparisonExp
  sku: StringComparisonExp
  tenantId: StringComparisonExp
  trialPeriodDays: IntComparisonExp
  updatedAt: TimestamptzComparisonExp
}

"""
columns and relationships of "shop_product_kind"
"""
type ShopProductKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "shop_product_kind". All fields are combined with a logical 'AND'.
"""
input ShopProductKindBoolExp {
  _and: [ShopProductKindBoolExp!]
  _not: ShopProductKindBoolExp
  _or: [ShopProductKindBoolExp!]
  id: StringComparisonExp
}

enum ShopProductKindEnum {
  DIGITAL
  EVENT_TICKET
  PHYSICAL
  SUBSCRIPTION
}

"""
Boolean expression to compare columns of type "ShopProductKindEnum". All fields are combined with logical 'AND'.
"""
input ShopProductKindEnumComparisonExp {
  _eq: ShopProductKindEnum
  _in: [ShopProductKindEnum!]
  _isNull: Boolean
  _neq: ShopProductKindEnum
  _nin: [ShopProductKindEnum!]
}

"""Ordering options when selecting data from "shop_product_kind"."""
input ShopProductKindOrderBy {
  id: OrderBy
}

"""
select columns of table "shop_product_kind"
"""
enum ShopProductKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "shop_product_kind"
"""
input ShopProductKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopProductKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopProductKindStreamCursorValueInput {
  id: String
}

"""Ordering options when selecting data from "shop_product"."""
input ShopProductOrderBy {
  createdAt: OrderBy
  description: OrderBy
  externalId: OrderBy
  id: OrderBy
  kind: OrderBy
  metadata: OrderBy
  name: OrderBy
  price: OrderBy
  sku: OrderBy
  tenantId: OrderBy
  trialPeriodDays: OrderBy
  updatedAt: OrderBy
}

"""
select columns of table "shop_product"
"""
enum ShopProductSelectColumn {
  """column name"""
  createdAt
  """column name"""
  description
  """column name"""
  externalId
  """column name"""
  id
  """column name"""
  kind
  """column name"""
  metadata
  """column name"""
  name
  """column name"""
  price
  """column name"""
  sku
  """column name"""
  tenantId
  """column name"""
  trialPeriodDays
  """column name"""
  updatedAt
}

"""
Streaming cursor of the table "shop_product"
"""
input ShopProductStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ShopProductStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ShopProductStreamCursorValueInput {
  createdAt: timestamptz
  description: String
  externalId: String
  id: uuid
  kind: ShopProductKindEnum
  metadata: jsonb
  name: String
  price: Int
  sku: String
  tenantId: String
  trialPeriodDays: Int
  updatedAt: timestamptz
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringArrayComparisonExp {
  """is the array contained in the given array value"""
  _containedIn: [String!]
  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _isNull: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String
  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean
  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """does the column NOT match the given pattern"""
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """does the column match the given SQL regular expression"""
  _similar: String
}

type SuccessOutput {
  success: Boolean!
}

"""
columns and relationships of "tenant"
"""
type Tenant {
  domain: citext!
  """url friendly version of name"""
  id: String!
  name: String!
  profileId: uuid
}

"""
Boolean expression to filter rows from the table "tenant". All fields are combined with a logical 'AND'.
"""
input TenantBoolExp {
  _and: [TenantBoolExp!]
  _not: TenantBoolExp
  _or: [TenantBoolExp!]
  domain: CitextComparisonExp
  id: StringComparisonExp
  name: StringComparisonExp
  profileId: UuidComparisonExp
}

"""Ordering options when selecting data from "tenant"."""
input TenantOrderBy {
  domain: OrderBy
  id: OrderBy
  name: OrderBy
  profileId: OrderBy
}

"""
select columns of table "tenant"
"""
enum TenantSelectColumn {
  """column name"""
  domain
  """column name"""
  id
  """column name"""
  name
  """column name"""
  profileId
}

"""
Streaming cursor of the table "tenant"
"""
input TenantStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: TenantStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input TenantStreamCursorValueInput {
  domain: citext
  """url friendly version of name"""
  id: String
  name: String
  profileId: uuid
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "value_kind"
"""
type ValueKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "value_kind". All fields are combined with a logical 'AND'.
"""
input ValueKindBoolExp {
  _and: [ValueKindBoolExp!]
  _not: ValueKindBoolExp
  _or: [ValueKindBoolExp!]
  id: StringComparisonExp
}

"""Ordering options when selecting data from "value_kind"."""
input ValueKindOrderBy {
  id: OrderBy
}

"""
select columns of table "value_kind"
"""
enum ValueKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "value_kind"
"""
input ValueKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: ValueKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input ValueKindStreamCursorValueInput {
  id: String
}

"""
columns and relationships of "visibility_kind"
"""
type VisibilityKind {
  id: String!
}

"""
Boolean expression to filter rows from the table "visibility_kind". All fields are combined with a logical 'AND'.
"""
input VisibilityKindBoolExp {
  _and: [VisibilityKindBoolExp!]
  _not: VisibilityKindBoolExp
  _or: [VisibilityKindBoolExp!]
  id: StringComparisonExp
}

enum VisibilityKindEnum {
  INTERNAL
  PRIVATE
  PUBLIC
}

"""
Boolean expression to compare columns of type "VisibilityKindEnum". All fields are combined with logical 'AND'.
"""
input VisibilityKindEnumComparisonExp {
  _eq: VisibilityKindEnum
  _in: [VisibilityKindEnum!]
  _isNull: Boolean
  _neq: VisibilityKindEnum
  _nin: [VisibilityKindEnum!]
}

"""Ordering options when selecting data from "visibility_kind"."""
input VisibilityKindOrderBy {
  id: OrderBy
}

"""
select columns of table "visibility_kind"
"""
enum VisibilityKindSelectColumn {
  """column name"""
  id
}

"""
Streaming cursor of the table "visibility_kind"
"""
input VisibilityKindStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: VisibilityKindStreamCursorValueInput!
  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input VisibilityKindStreamCursorValueInput {
  id: String
}

scalar citext

scalar date

input gameRafflePrizeAggregateBoolExpCount {
  arguments: [GameRafflePrizeSelectColumn!]
  distinct: Boolean
  filter: GameRafflePrizeBoolExp
  predicate: IntComparisonExp!
}

input gameRaffleTicketOptionAggregateBoolExpBool_and {
  arguments: GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_andArgumentsColumns!
  distinct: Boolean
  filter: GameRaffleTicketOptionBoolExp
  predicate: BooleanComparisonExp!
}

input gameRaffleTicketOptionAggregateBoolExpBool_or {
  arguments: GameRaffleTicketOptionSelectColumnGameRaffleTicketOptionAggregateBoolExpBool_orArgumentsColumns!
  distinct: Boolean
  filter: GameRaffleTicketOptionBoolExp
  predicate: BooleanComparisonExp!
}

input gameRaffleTicketOptionAggregateBoolExpCount {
  arguments: [GameRaffleTicketOptionSelectColumn!]
  distinct: Boolean
  filter: GameRaffleTicketOptionBoolExp
  predicate: IntComparisonExp!
}

scalar jsonb

"""mutation root"""
type mutation_root {
  authAnonymousSignIn(args: AuthAnonymousInput!): AuthOutput
  authEmailSendVerification(args: AuthEmailInput!): AuthOutput
  authEmailVerify(args: AuthEmailTicketInput!): AuthOutput
  authMagicLinkSendEmail(args: AuthEmailInput!): AuthOutput
  authMagicLinkSignIn(args: AuthEmailTicketInput!): AuthOutput
  authMagicLinkSignUpAndSend(args: AuthEmailSignupInput!): AuthOutput
  authPasswordReset(args: AuthResetPasswordInput!): AuthOutput
  authPasswordSendResetEmail(args: AuthEmailInput!): AuthOutput
  authPasswordSignIn(args: AuthEmailPasswordInput!): AuthOutput
  authPasswordSignUpAndSendVerification(args: AuthEmailPasswordSignUpInput!): AuthOutput
  authSmsSendCode(args: AuthSmsInput!): AuthOutput
  authSmsSignIn(args: AuthSmsCodeInput!): AuthOutput
  authSmsSignUpAndSend(args: AuthSmsSignUpInput!): AuthOutput
  authSmsVerify(args: AuthSmsCodeInput!): AuthOutput
  submitContactForm(args: ContactFormInput!): SuccessOutput
  submitFeedback(args: FeedbackInput!): FeedbackOutput
}

scalar numeric

input profileFollowerAggregateBoolExpCount {
  arguments: [ProfileFollowerSelectColumn!]
  distinct: Boolean
  filter: ProfileFollowerBoolExp
  predicate: IntComparisonExp!
}

type query_root {
  """
  fetch data from the table: "auth_role_kind"
  """
  authRoleKind(
    """distinct select on columns"""
    distinctOn: [AuthRoleKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuthRoleKindOrderBy!]
    """filter the rows returned"""
    where: AuthRoleKindBoolExp
  ): [AuthRoleKind!]!
  """fetch data from the table: "auth_role_kind" using primary key columns"""
  authRoleKindByPk(id: String!): AuthRoleKind
  """
  fetch data from the table: "document"
  """
  document(
    """distinct select on columns"""
    distinctOn: [DocumentSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentOrderBy!]
    """filter the rows returned"""
    where: DocumentBoolExp
  ): [Document!]!
  """
  fetch data from the table: "document_block"
  """
  documentBlock(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]
    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!
  """fetch data from the table: "document_block" using primary key columns"""
  documentBlockByPk(id: uuid!): DocumentBlock
  """
  fetch data from the table: "document_block_kind"
  """
  documentBlockKind(
    """distinct select on columns"""
    distinctOn: [DocumentBlockKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockKindOrderBy!]
    """filter the rows returned"""
    where: DocumentBlockKindBoolExp
  ): [DocumentBlockKind!]!
  """
  fetch data from the table: "document_block_kind" using primary key columns
  """
  documentBlockKindByPk(id: String!): DocumentBlockKind
  """fetch data from the table: "document" using primary key columns"""
  documentByPk(id: uuid!): Document
  """
  fetch data from the table: "document_kind"
  """
  documentKind(
    """distinct select on columns"""
    distinctOn: [DocumentKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentKindOrderBy!]
    """filter the rows returned"""
    where: DocumentKindBoolExp
  ): [DocumentKind!]!
  """fetch data from the table: "document_kind" using primary key columns"""
  documentKindByPk(id: String!): DocumentKind
  """
  fetch data from the table: "event"
  """
  event(
    """distinct select on columns"""
    distinctOn: [EventSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventOrderBy!]
    """filter the rows returned"""
    where: EventBoolExp
  ): [Event!]!
  """
  fetch data from the table: "event_availability_kind"
  """
  eventAvailabilityKind(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityKindOrderBy!]
    """filter the rows returned"""
    where: EventAvailabilityKindBoolExp
  ): [EventAvailabilityKind!]!
  """
  fetch data from the table: "event_availability_kind" using primary key columns
  """
  eventAvailabilityKindByPk(id: String!): EventAvailabilityKind
  """fetch data from the table: "event" using primary key columns"""
  eventByPk(id: uuid!): Event
  """
  fetch data from the table: "event_live"
  """
  eventLive(
    """distinct select on columns"""
    distinctOn: [EventLiveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventLiveOrderBy!]
    """filter the rows returned"""
    where: EventLiveBoolExp
  ): [EventLive!]!
  """fetch data from the table: "event_live" using primary key columns"""
  eventLiveByPk(id: String!): EventLive
  """
  fetch data from the table: "event_recurrence"
  """
  eventRecurrence(
    """distinct select on columns"""
    distinctOn: [EventRecurrenceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventRecurrenceOrderBy!]
    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): [EventRecurrence!]!
  """
  fetch data from the table: "event_recurrence" using primary key columns
  """
  eventRecurrenceByPk(id: uuid!): EventRecurrence
  """
  fetch data from the table: "event_ticket_option"
  """
  eventTicketOption(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]
    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!
  """
  fetch data from the table: "event_ticket_option" using primary key columns
  """
  eventTicketOptionByPk(eventId: uuid!, productId: uuid!, tenantId: String!): EventTicketOption
  """
  fetch data from the table: "game_raffle"
  """
  gameRaffle(
    """distinct select on columns"""
    distinctOn: [GameRaffleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleOrderBy!]
    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): [GameRaffle!]!
  """fetch data from the table: "game_raffle" using primary key columns"""
  gameRaffleByPk(id: uuid!): GameRaffle
  """
  fetch data from the table: "game_raffle_prize"
  """
  gameRafflePrize(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]
    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!
  """
  fetch aggregated fields from the table: "game_raffle_prize"
  """
  gameRafflePrizeAggregate(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]
    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): GameRafflePrizeAggregate!
  """
  fetch data from the table: "game_raffle_prize" using primary key columns
  """
  gameRafflePrizeByPk(id: uuid!): GameRafflePrize
  """
  fetch data from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOption(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]
    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!
  """
  fetch aggregated fields from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOptionAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]
    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): GameRaffleTicketOptionAggregate!
  """
  fetch data from the table: "game_raffle_ticket_option" using primary key columns
  """
  gameRaffleTicketOptionByPk(id: uuid!): GameRaffleTicketOption
  """
  fetch data from the table: "geo_location"
  """
  geoLocation(
    """distinct select on columns"""
    distinctOn: [GeoLocationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GeoLocationOrderBy!]
    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): [GeoLocation!]!
  """fetch data from the table: "geo_location" using primary key columns"""
  geoLocationByPk(id: uuid!): GeoLocation
  """
  fetch data from the table: "media_item"
  """
  mediaItem(
    """distinct select on columns"""
    distinctOn: [MediaItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [MediaItemOrderBy!]
    """filter the rows returned"""
    where: MediaItemBoolExp
  ): [MediaItem!]!
  """fetch data from the table: "media_item" using primary key columns"""
  mediaItemByPk(id: String!): MediaItem
  """
  fetch data from the table: "media_item_tag"
  """
  mediaItemTag(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]
    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!
  """fetch data from the table: "media_item_tag" using primary key columns"""
  mediaItemTagByPk(mediaItemId: String!, tag: String!): MediaItemTag
  """
  fetch data from the table: "media_kind"
  """
  mediaKind(
    """distinct select on columns"""
    distinctOn: [MediaKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [MediaKindOrderBy!]
    """filter the rows returned"""
    where: MediaKindBoolExp
  ): [MediaKind!]!
  """fetch data from the table: "media_kind" using primary key columns"""
  mediaKindByPk(id: String!): MediaKind
  """
  fetch data from the table: "post_reaction_kind"
  """
  postReactionKind(
    """distinct select on columns"""
    distinctOn: [PostReactionKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PostReactionKindOrderBy!]
    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): [PostReactionKind!]!
  """
  fetch data from the table: "post_reaction_kind" using primary key columns
  """
  postReactionKindByPk(id: String!, tenantId: String!): PostReactionKind
  """
  fetch data from the table: "profile"
  """
  profile(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]
    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!
  """
  fetch data from the table: "profile_attribute"
  """
  profileAttribute(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]
    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!
  """fetch data from the table: "profile" using primary key columns"""
  profileByPk(id: uuid!): Profile
  profileCheckUsername(args: ProfileCheckUsernameInput!): ProfileCheckUsernameOutput
  """
  fetch data from the table: "profile_follower"
  """
  profileFollower(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!
  """
  fetch aggregated fields from the table: "profile_follower"
  """
  profileFollowerAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!
  """
  fetch data from the table: "profile_follower" using primary key columns
  """
  profileFollowerByPk(followedProfileId: uuid!, followerId: uuid!): ProfileFollower
  """
  fetch data from the table: "question_kind"
  """
  questionKind(
    """distinct select on columns"""
    distinctOn: [QuestionKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuestionKindOrderBy!]
    """filter the rows returned"""
    where: QuestionKindBoolExp
  ): [QuestionKind!]!
  """fetch data from the table: "question_kind" using primary key columns"""
  questionKindByPk(id: String!): QuestionKind
  """
  fetch data from the table: "shop_product"
  """
  shopProduct(
    """distinct select on columns"""
    distinctOn: [ShopProductSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ShopProductOrderBy!]
    """filter the rows returned"""
    where: ShopProductBoolExp
  ): [ShopProduct!]!
  """fetch data from the table: "shop_product" using primary key columns"""
  shopProductByPk(id: uuid!): ShopProduct
  """
  fetch data from the table: "shop_product_kind"
  """
  shopProductKind(
    """distinct select on columns"""
    distinctOn: [ShopProductKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ShopProductKindOrderBy!]
    """filter the rows returned"""
    where: ShopProductKindBoolExp
  ): [ShopProductKind!]!
  """
  fetch data from the table: "shop_product_kind" using primary key columns
  """
  shopProductKindByPk(id: String!): ShopProductKind
  """
  fetch data from the table: "tenant"
  """
  tenant(
    """distinct select on columns"""
    distinctOn: [TenantSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TenantOrderBy!]
    """filter the rows returned"""
    where: TenantBoolExp
  ): [Tenant!]!
  """fetch data from the table: "tenant" using primary key columns"""
  tenantByPk(
    """url friendly version of name"""
    id: String!
  ): Tenant
  """
  fetch data from the table: "value_kind"
  """
  valueKind(
    """distinct select on columns"""
    distinctOn: [ValueKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ValueKindOrderBy!]
    """filter the rows returned"""
    where: ValueKindBoolExp
  ): [ValueKind!]!
  """fetch data from the table: "value_kind" using primary key columns"""
  valueKindByPk(id: String!): ValueKind
  """
  fetch data from the table: "visibility_kind"
  """
  visibilityKind(
    """distinct select on columns"""
    distinctOn: [VisibilityKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [VisibilityKindOrderBy!]
    """filter the rows returned"""
    where: VisibilityKindBoolExp
  ): [VisibilityKind!]!
  """fetch data from the table: "visibility_kind" using primary key columns"""
  visibilityKindByPk(id: String!): VisibilityKind
}

type subscription_root {
  """
  fetch data from the table: "auth_role_kind"
  """
  authRoleKind(
    """distinct select on columns"""
    distinctOn: [AuthRoleKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [AuthRoleKindOrderBy!]
    """filter the rows returned"""
    where: AuthRoleKindBoolExp
  ): [AuthRoleKind!]!
  """fetch data from the table: "auth_role_kind" using primary key columns"""
  authRoleKindByPk(id: String!): AuthRoleKind
  """
  fetch data from the table in a streaming manner: "auth_role_kind"
  """
  authRoleKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [AuthRoleKindStreamCursorInput]!
    """filter the rows returned"""
    where: AuthRoleKindBoolExp
  ): [AuthRoleKind!]!
  """
  fetch data from the table: "document"
  """
  document(
    """distinct select on columns"""
    distinctOn: [DocumentSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentOrderBy!]
    """filter the rows returned"""
    where: DocumentBoolExp
  ): [Document!]!
  """
  fetch data from the table: "document_block"
  """
  documentBlock(
    """distinct select on columns"""
    distinctOn: [DocumentBlockSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockOrderBy!]
    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!
  """fetch data from the table: "document_block" using primary key columns"""
  documentBlockByPk(id: uuid!): DocumentBlock
  """
  fetch data from the table: "document_block_kind"
  """
  documentBlockKind(
    """distinct select on columns"""
    distinctOn: [DocumentBlockKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentBlockKindOrderBy!]
    """filter the rows returned"""
    where: DocumentBlockKindBoolExp
  ): [DocumentBlockKind!]!
  """
  fetch data from the table: "document_block_kind" using primary key columns
  """
  documentBlockKindByPk(id: String!): DocumentBlockKind
  """
  fetch data from the table in a streaming manner: "document_block_kind"
  """
  documentBlockKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [DocumentBlockKindStreamCursorInput]!
    """filter the rows returned"""
    where: DocumentBlockKindBoolExp
  ): [DocumentBlockKind!]!
  """
  fetch data from the table in a streaming manner: "document_block"
  """
  documentBlockStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [DocumentBlockStreamCursorInput]!
    """filter the rows returned"""
    where: DocumentBlockBoolExp
  ): [DocumentBlock!]!
  """fetch data from the table: "document" using primary key columns"""
  documentByPk(id: uuid!): Document
  """
  fetch data from the table: "document_kind"
  """
  documentKind(
    """distinct select on columns"""
    distinctOn: [DocumentKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [DocumentKindOrderBy!]
    """filter the rows returned"""
    where: DocumentKindBoolExp
  ): [DocumentKind!]!
  """fetch data from the table: "document_kind" using primary key columns"""
  documentKindByPk(id: String!): DocumentKind
  """
  fetch data from the table in a streaming manner: "document_kind"
  """
  documentKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [DocumentKindStreamCursorInput]!
    """filter the rows returned"""
    where: DocumentKindBoolExp
  ): [DocumentKind!]!
  """
  fetch data from the table in a streaming manner: "document"
  """
  documentStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [DocumentStreamCursorInput]!
    """filter the rows returned"""
    where: DocumentBoolExp
  ): [Document!]!
  """
  fetch data from the table: "event"
  """
  event(
    """distinct select on columns"""
    distinctOn: [EventSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventOrderBy!]
    """filter the rows returned"""
    where: EventBoolExp
  ): [Event!]!
  """
  fetch data from the table: "event_availability_kind"
  """
  eventAvailabilityKind(
    """distinct select on columns"""
    distinctOn: [EventAvailabilityKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventAvailabilityKindOrderBy!]
    """filter the rows returned"""
    where: EventAvailabilityKindBoolExp
  ): [EventAvailabilityKind!]!
  """
  fetch data from the table: "event_availability_kind" using primary key columns
  """
  eventAvailabilityKindByPk(id: String!): EventAvailabilityKind
  """
  fetch data from the table in a streaming manner: "event_availability_kind"
  """
  eventAvailabilityKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EventAvailabilityKindStreamCursorInput]!
    """filter the rows returned"""
    where: EventAvailabilityKindBoolExp
  ): [EventAvailabilityKind!]!
  """fetch data from the table: "event" using primary key columns"""
  eventByPk(id: uuid!): Event
  """
  fetch data from the table: "event_live"
  """
  eventLive(
    """distinct select on columns"""
    distinctOn: [EventLiveSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventLiveOrderBy!]
    """filter the rows returned"""
    where: EventLiveBoolExp
  ): [EventLive!]!
  """fetch data from the table: "event_live" using primary key columns"""
  eventLiveByPk(id: String!): EventLive
  """
  fetch data from the table in a streaming manner: "event_live"
  """
  eventLiveStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EventLiveStreamCursorInput]!
    """filter the rows returned"""
    where: EventLiveBoolExp
  ): [EventLive!]!
  """
  fetch data from the table: "event_recurrence"
  """
  eventRecurrence(
    """distinct select on columns"""
    distinctOn: [EventRecurrenceSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventRecurrenceOrderBy!]
    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): [EventRecurrence!]!
  """
  fetch data from the table: "event_recurrence" using primary key columns
  """
  eventRecurrenceByPk(id: uuid!): EventRecurrence
  """
  fetch data from the table in a streaming manner: "event_recurrence"
  """
  eventRecurrenceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EventRecurrenceStreamCursorInput]!
    """filter the rows returned"""
    where: EventRecurrenceBoolExp
  ): [EventRecurrence!]!
  """
  fetch data from the table in a streaming manner: "event"
  """
  eventStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EventStreamCursorInput]!
    """filter the rows returned"""
    where: EventBoolExp
  ): [Event!]!
  """
  fetch data from the table: "event_ticket_option"
  """
  eventTicketOption(
    """distinct select on columns"""
    distinctOn: [EventTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [EventTicketOptionOrderBy!]
    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!
  """
  fetch data from the table: "event_ticket_option" using primary key columns
  """
  eventTicketOptionByPk(eventId: uuid!, productId: uuid!, tenantId: String!): EventTicketOption
  """
  fetch data from the table in a streaming manner: "event_ticket_option"
  """
  eventTicketOptionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [EventTicketOptionStreamCursorInput]!
    """filter the rows returned"""
    where: EventTicketOptionBoolExp
  ): [EventTicketOption!]!
  """
  fetch data from the table: "game_raffle"
  """
  gameRaffle(
    """distinct select on columns"""
    distinctOn: [GameRaffleSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleOrderBy!]
    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): [GameRaffle!]!
  """fetch data from the table: "game_raffle" using primary key columns"""
  gameRaffleByPk(id: uuid!): GameRaffle
  """
  fetch data from the table: "game_raffle_prize"
  """
  gameRafflePrize(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]
    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!
  """
  fetch aggregated fields from the table: "game_raffle_prize"
  """
  gameRafflePrizeAggregate(
    """distinct select on columns"""
    distinctOn: [GameRafflePrizeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRafflePrizeOrderBy!]
    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): GameRafflePrizeAggregate!
  """
  fetch data from the table: "game_raffle_prize" using primary key columns
  """
  gameRafflePrizeByPk(id: uuid!): GameRafflePrize
  """
  fetch data from the table in a streaming manner: "game_raffle_prize"
  """
  gameRafflePrizeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [GameRafflePrizeStreamCursorInput]!
    """filter the rows returned"""
    where: GameRafflePrizeBoolExp
  ): [GameRafflePrize!]!
  """
  fetch data from the table in a streaming manner: "game_raffle"
  """
  gameRaffleStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [GameRaffleStreamCursorInput]!
    """filter the rows returned"""
    where: GameRaffleBoolExp
  ): [GameRaffle!]!
  """
  fetch data from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOption(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]
    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!
  """
  fetch aggregated fields from the table: "game_raffle_ticket_option"
  """
  gameRaffleTicketOptionAggregate(
    """distinct select on columns"""
    distinctOn: [GameRaffleTicketOptionSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GameRaffleTicketOptionOrderBy!]
    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): GameRaffleTicketOptionAggregate!
  """
  fetch data from the table: "game_raffle_ticket_option" using primary key columns
  """
  gameRaffleTicketOptionByPk(id: uuid!): GameRaffleTicketOption
  """
  fetch data from the table in a streaming manner: "game_raffle_ticket_option"
  """
  gameRaffleTicketOptionStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [GameRaffleTicketOptionStreamCursorInput]!
    """filter the rows returned"""
    where: GameRaffleTicketOptionBoolExp
  ): [GameRaffleTicketOption!]!
  """
  fetch data from the table: "geo_location"
  """
  geoLocation(
    """distinct select on columns"""
    distinctOn: [GeoLocationSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [GeoLocationOrderBy!]
    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): [GeoLocation!]!
  """fetch data from the table: "geo_location" using primary key columns"""
  geoLocationByPk(id: uuid!): GeoLocation
  """
  fetch data from the table in a streaming manner: "geo_location"
  """
  geoLocationStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [GeoLocationStreamCursorInput]!
    """filter the rows returned"""
    where: GeoLocationBoolExp
  ): [GeoLocation!]!
  """
  fetch data from the table: "media_item"
  """
  mediaItem(
    """distinct select on columns"""
    distinctOn: [MediaItemSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [MediaItemOrderBy!]
    """filter the rows returned"""
    where: MediaItemBoolExp
  ): [MediaItem!]!
  """fetch data from the table: "media_item" using primary key columns"""
  mediaItemByPk(id: String!): MediaItem
  """
  fetch data from the table in a streaming manner: "media_item"
  """
  mediaItemStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [MediaItemStreamCursorInput]!
    """filter the rows returned"""
    where: MediaItemBoolExp
  ): [MediaItem!]!
  """
  fetch data from the table: "media_item_tag"
  """
  mediaItemTag(
    """distinct select on columns"""
    distinctOn: [MediaItemTagSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [MediaItemTagOrderBy!]
    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!
  """fetch data from the table: "media_item_tag" using primary key columns"""
  mediaItemTagByPk(mediaItemId: String!, tag: String!): MediaItemTag
  """
  fetch data from the table in a streaming manner: "media_item_tag"
  """
  mediaItemTagStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [MediaItemTagStreamCursorInput]!
    """filter the rows returned"""
    where: MediaItemTagBoolExp
  ): [MediaItemTag!]!
  """
  fetch data from the table: "media_kind"
  """
  mediaKind(
    """distinct select on columns"""
    distinctOn: [MediaKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [MediaKindOrderBy!]
    """filter the rows returned"""
    where: MediaKindBoolExp
  ): [MediaKind!]!
  """fetch data from the table: "media_kind" using primary key columns"""
  mediaKindByPk(id: String!): MediaKind
  """
  fetch data from the table in a streaming manner: "media_kind"
  """
  mediaKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [MediaKindStreamCursorInput]!
    """filter the rows returned"""
    where: MediaKindBoolExp
  ): [MediaKind!]!
  """
  fetch data from the table: "post_reaction_kind"
  """
  postReactionKind(
    """distinct select on columns"""
    distinctOn: [PostReactionKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [PostReactionKindOrderBy!]
    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): [PostReactionKind!]!
  """
  fetch data from the table: "post_reaction_kind" using primary key columns
  """
  postReactionKindByPk(id: String!, tenantId: String!): PostReactionKind
  """
  fetch data from the table in a streaming manner: "post_reaction_kind"
  """
  postReactionKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [PostReactionKindStreamCursorInput]!
    """filter the rows returned"""
    where: PostReactionKindBoolExp
  ): [PostReactionKind!]!
  """
  fetch data from the table: "profile"
  """
  profile(
    """distinct select on columns"""
    distinctOn: [ProfileSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileOrderBy!]
    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!
  """
  fetch data from the table: "profile_attribute"
  """
  profileAttribute(
    """distinct select on columns"""
    distinctOn: [ProfileAttributeSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileAttributeOrderBy!]
    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!
  """
  fetch data from the table in a streaming manner: "profile_attribute"
  """
  profileAttributeStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ProfileAttributeStreamCursorInput]!
    """filter the rows returned"""
    where: ProfileAttributeBoolExp
  ): [ProfileAttribute!]!
  """fetch data from the table: "profile" using primary key columns"""
  profileByPk(id: uuid!): Profile
  """
  fetch data from the table: "profile_follower"
  """
  profileFollower(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!
  """
  fetch aggregated fields from the table: "profile_follower"
  """
  profileFollowerAggregate(
    """distinct select on columns"""
    distinctOn: [ProfileFollowerSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ProfileFollowerOrderBy!]
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): ProfileFollowerAggregate!
  """
  fetch data from the table: "profile_follower" using primary key columns
  """
  profileFollowerByPk(followedProfileId: uuid!, followerId: uuid!): ProfileFollower
  """
  fetch data from the table in a streaming manner: "profile_follower"
  """
  profileFollowerStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ProfileFollowerStreamCursorInput]!
    """filter the rows returned"""
    where: ProfileFollowerBoolExp
  ): [ProfileFollower!]!
  """
  fetch data from the table in a streaming manner: "profile"
  """
  profileStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ProfileStreamCursorInput]!
    """filter the rows returned"""
    where: ProfileBoolExp
  ): [Profile!]!
  """
  fetch data from the table: "question_kind"
  """
  questionKind(
    """distinct select on columns"""
    distinctOn: [QuestionKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [QuestionKindOrderBy!]
    """filter the rows returned"""
    where: QuestionKindBoolExp
  ): [QuestionKind!]!
  """fetch data from the table: "question_kind" using primary key columns"""
  questionKindByPk(id: String!): QuestionKind
  """
  fetch data from the table in a streaming manner: "question_kind"
  """
  questionKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [QuestionKindStreamCursorInput]!
    """filter the rows returned"""
    where: QuestionKindBoolExp
  ): [QuestionKind!]!
  """
  fetch data from the table: "shop_product"
  """
  shopProduct(
    """distinct select on columns"""
    distinctOn: [ShopProductSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ShopProductOrderBy!]
    """filter the rows returned"""
    where: ShopProductBoolExp
  ): [ShopProduct!]!
  """fetch data from the table: "shop_product" using primary key columns"""
  shopProductByPk(id: uuid!): ShopProduct
  """
  fetch data from the table: "shop_product_kind"
  """
  shopProductKind(
    """distinct select on columns"""
    distinctOn: [ShopProductKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ShopProductKindOrderBy!]
    """filter the rows returned"""
    where: ShopProductKindBoolExp
  ): [ShopProductKind!]!
  """
  fetch data from the table: "shop_product_kind" using primary key columns
  """
  shopProductKindByPk(id: String!): ShopProductKind
  """
  fetch data from the table in a streaming manner: "shop_product_kind"
  """
  shopProductKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ShopProductKindStreamCursorInput]!
    """filter the rows returned"""
    where: ShopProductKindBoolExp
  ): [ShopProductKind!]!
  """
  fetch data from the table in a streaming manner: "shop_product"
  """
  shopProductStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ShopProductStreamCursorInput]!
    """filter the rows returned"""
    where: ShopProductBoolExp
  ): [ShopProduct!]!
  """
  fetch data from the table: "tenant"
  """
  tenant(
    """distinct select on columns"""
    distinctOn: [TenantSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [TenantOrderBy!]
    """filter the rows returned"""
    where: TenantBoolExp
  ): [Tenant!]!
  """fetch data from the table: "tenant" using primary key columns"""
  tenantByPk(
    """url friendly version of name"""
    id: String!
  ): Tenant
  """
  fetch data from the table in a streaming manner: "tenant"
  """
  tenantStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [TenantStreamCursorInput]!
    """filter the rows returned"""
    where: TenantBoolExp
  ): [Tenant!]!
  """
  fetch data from the table: "value_kind"
  """
  valueKind(
    """distinct select on columns"""
    distinctOn: [ValueKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [ValueKindOrderBy!]
    """filter the rows returned"""
    where: ValueKindBoolExp
  ): [ValueKind!]!
  """fetch data from the table: "value_kind" using primary key columns"""
  valueKindByPk(id: String!): ValueKind
  """
  fetch data from the table in a streaming manner: "value_kind"
  """
  valueKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [ValueKindStreamCursorInput]!
    """filter the rows returned"""
    where: ValueKindBoolExp
  ): [ValueKind!]!
  """
  fetch data from the table: "visibility_kind"
  """
  visibilityKind(
    """distinct select on columns"""
    distinctOn: [VisibilityKindSelectColumn!]
    """limit the number of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    orderBy: [VisibilityKindOrderBy!]
    """filter the rows returned"""
    where: VisibilityKindBoolExp
  ): [VisibilityKind!]!
  """fetch data from the table: "visibility_kind" using primary key columns"""
  visibilityKindByPk(id: String!): VisibilityKind
  """
  fetch data from the table in a streaming manner: "visibility_kind"
  """
  visibilityKindStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!
    """cursor to stream the results returned by the query"""
    cursor: [VisibilityKindStreamCursorInput]!
    """filter the rows returned"""
    where: VisibilityKindBoolExp
  ): [VisibilityKind!]!
}

scalar timestamptz

scalar uuid